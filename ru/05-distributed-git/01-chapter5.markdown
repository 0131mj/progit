# Распределённый Git #

Теперь, когда вы обзавелись настроенным удалённым Git-репозиторием, являющимся местом, где разработчики могут обмениваться своим кодом, а также познакомились с основными командами Git'а для локальной работы, мы рассмотрим как задействовать некоторые распределённые рабочие процессы, предлагаемые Git'ом.

В этой главе мы рассмотрим работу с Git'ом в распределённой среде как в роли рядового разработчика, так и в роли системного интегратора. То есть вы научитесь успешно вносить свой код в проект, делая это как можно более просто и для вас, и для владельца проекта, а также научитесь тому, как сопровождать проекты, в работе над которыми участвует множество человек.

## Распределённые рабочие процессы ##

В отличие от централизованных систем управления версиями, распределённая природа Git'а позволяет вам быть гораздо более гибким в отношении участия разработчиков в работе над проектами. В централизованных системах все разработчики являются узлами сети, более или менее одинаково работающими на центральном хабе. Однако, в Git каждый разработчик потенциально является и узлом, и хабом. То есть каждый разработчик может как вносить код в другие репозитории, так и содержать публичный репозиторий, на основе которого работают другие разработчики, и в который они вносят свои изменения. Это даёт вашей команде возможность осуществлять любой из множества различных способов осуществления рабочего процесса в ваших проектах, поэтому мы рассмотрим несколько распространённых подходов, пользующихся гибкостью Git'а. Мы рассмотрим сильные стороны и возможные недостатки каждого подхода; вы можете выбрать для себя один из них, а можете совместить особенности сразу нескольких подходов.

### Централизованный рабочий процесс ###

В централизованных системах существует, как правило, одна модель совместной разработки — централизованный рабочий процесс. Один центральный хаб, или репозиторий, может принимать код, а все остальные синхронизируют свою работу с ним. Некоторое число разработчиков являются узлами — клиентами этого хаба — и синхронизируются с ним одним (смотри Рисунок 5-1).

Insert 18333fig0501.png
Рисунок 5-1. Централизованный рабочий процесс.

Это значит, что если два разработчика выполняют клонирование с хаба, и оба делают изменения в проекте, то первый из них, кто отправит свои изменения обратно на хаб, сделает это без проблем. Второй разработчик должен взять наработки первого и выполнить слияние перед тем, как отправить свои изменения, так чтобы не перезаписать изменения первого разработчика. Этот принцип справедлив для Git точно также, как и для Subversion (или любой другой ЦСУВ), и в Git такая модель работает отлично.

Если у вас небольшая команда или вас полностью устраивает рабочий процесс централизованного типа, применяемый в вашей компании, вы можете просто продолжить использовать такой рабочий процесс и в Git. Просто настройте один репозиторий и дайте каждому в вашей команде права на отправку изменений; Git не позволит пользователям перезаписывать наработки друг-друга. Если какой-то разработчик склонирует репозиторий, сделает в нём изменения, а затем попытается выложить эти изменения, в то время как другой разработчик уже успел отправить свои, сервер отклонит изменения этого разработчика. Ему будет сказано, что он пытается выложить изменения, для которых невозможно выполнить перемотку (fast-forward), и что надо сначала извлечь данные с сервера, выполнить слияние, а уже потом отправлять свои изменения. Такой рабочий процесс привлекателен для большого количества людей, так как это та модель, с которой многие знакомы, и которая многим понятна.

### Рабочий процесс с менеджером по интеграции ###

Так как Git позволяет иметь несколько удалённых репозиториев, существует возможность ведения такого рабочего процесса, при котором каждый разработчик имеет права на запись в свой собственный публичный репозиторий и права на чтение для всех остальных. Этот сценарий часто подразумевает существование канонического репозитория, который представляет собой "официальный" проект. Чтобы принять участие в работе над этим проектом, надо создать свою собственную публичную копию проекта и выложить туда свои изменения. Потом вы можете отправить запрос владельцу основного проекта на внесение в него ваших изменений. Он может добавить ваш репозиторий в качестве удалённого, протестировать локально ваши изменения, слить их со своей веткой и затем отправить обратно в публичный репозиторий. Этот процесс осуществляется следующим образом (смотри Рисунок 5-2):

1.	Владелец проекта выкладывает файлы в публичный репозиторий.
2.	Участники проекта клонируют этот репозиторий и делают изменения.
3.	Участники выкладывают изменения в свои собственные публичные репозитории.
4.	Участник проекта отправляет владельцу письмо с просьбой включения его изменений.
5.	Владелец проекта добавляет репозиторий участника как удалённый и локально выполняет слияние.
6.	Владелец отправляет слитые изменения в основной репозиторий.

Insert 18333fig0502.png 
Рисунок 5-2. Рабочий процесс с менеджером по интеграции.

Это очень распространённый тип рабочего процесса для сайтов вроде GitHub, где можно легко форкнуть проект и выложить свои изменения на всеобщее обозрение в собственную копию. Одно из главных преимуществ такого подхода — возможность продолжать работать, в то время, как владелец основного репозитория может включить себе ваши изменения, когда ему угодно. Участникам проекта не придётся ждать, пока их изменения не будут включены в проект — каждый может работать в своём собственном ритме.

### Рабочий процесс с диктатором и его помощниками ###

Это одна из разновидностей рабочего процесса с множеством репозиториев. В основном он используется в огромных проектах с сотнями участников; ядро Linux яркий тому пример. Несколько менеджеров по интеграции заведуют разными частями репозитория; этих людей называют помощниками. У всех этих помощников есть только один менеджер по интеграции, которого называют благосклонным диктатором. Репозиторий благосклонного диктатора служит эталонным репозиторием, откуда все участники проекта должны брать изменения. Этот процесс происходит так (смотри Рисунок 5-3):

1.	Обычные разработчики работают над своими тематическими ветками и перемещают свою работу на вершину ветки master. Ветка master — это та ветка, которая находится у диктатора.
2.	Помощники сливают тематические ветки разработчиков в свои ветки master.
3.	Диктатор выполняет слияние веток master своих помощников со своей веткой master.
4.	Диктатор отправляет свою ветку master в эталонный репозиторий, чтобы остальные разработчики могли выполнять перемещение на неё.

Insert 18333fig0503.png
Рисунок 5-3. Рабочий процесс с благосклонным диктатором.

Этот тип рабочего процесса не является распространённым, но он может быть полезен в очень больших проектах или в сильно иерархическом окружении, так как он позволяет лидеру проекта (диктатору) передать другим полномочия по выполнению большой части работ и собирать код большими порциями с нескольких мест перед его интеграцией.

Мы рассмотрели несколько широко используемых типов рабочих процессов доступных при работе с распределёнными системами вроде Git, но, как видите, возможны различные вариации для подгонки под ваш конкретный тип рабочего процесса. Теперь, когда вы в состоянии определить, какая комбинация рабочих процессов сработает для вас лучше, мы рассмотрим несколько более специфичных примеров действий, выполняемых основными ролями участников различных процессов.

## Содействие проекту ##

Мы узнали, что представляют собой различные рабочие процессы, также у вас должно быть достаточно хорошее понимание основ использования Git. В этом разделе вы узнаете о нескольких типичных способах внести свой вклад в проект.

Главная трудность в описании этого процесса состоит в том, что существует огромное количество вариаций того, как он организован. Так как Git очень гибок, люди могут осуществлять совместную работу по-разному, и проблематично описать то, как вы должны содействовать проекту — все проекты немного разные. Многое зависит от количества активных участников, от выбранного типа рабочего процесса, от ваших прав доступа к репозиториям, и, возможно, от метода принятия изменений от внешних разработчиков.

Первый фактор — это количество активных участников. Как много пользователей активно вносят свой вклад в проект и как часто? Во многих случаях это два-три разработчика с несколькими коммитами в день, возможно, меньше, для вялотекущих проектов. В по-настоящему больших компаниях или проектах число разработчиков может измеряться тысячами, с десятками или даже сотнями ежедневно поступающих патчей. Это важно, поскольку с увеличением числа разработчиков вам становится труднее убедиться, что ваши изменения можно будет чисто применить или беспрепятственно слить. Изменения, которые вы отправляете, могут оказаться устаревшими или частично сломанными той работой, которая была влита, пока вы работали, или пока ваши изменения ожидали утверждения или применения. Как сохранить свой код согласованным, а патчи применимыми?

Следующий фактор — это рабочий процесс, используемый в проекте. Он централизован, и каждый разработчик имеет равные права на запись в главный репозиторий? Есть у проекта мейнтейнер или менеджер по интеграции, который проверяет патчи? Все ли патчи проверяются и утверждаются экспертами? Вы вовлечены в этот процесс? Присутствует ли система помощников и должны ли вы сначала отправлять свою работу им?

Следующий пункт — это доступ на отправку изменений. Рабочий процесс, требуемый для внесения вклада в проект сильно отличается в зависимости от того, имеете ли вы доступ на запись или нет. Если у вас нет доступа на запись, то как в проекте принято принимать вклад в работу? Вообще, существует ли какая-либо политика? Какой объём работы вы вносите за раз? Как часто вы это делаете?

Все эти вопросы могу повлиять на то, как эффективно вы будете вносить вклад в проект и какой рабочий процесс предпочтителен или доступен вам. Я расскажу об аспектах каждого из них на серии примеров, продвигаясь от простых к более сложным; на основе этих примеров вы сможете создать специфический нужный вам в вашей работе тип рабочего процесса.

### Рекомендации по созданию коммитов ###

Прежде чем мы приступим к рассмотрению специфичных примеров использования, сделаем короткое замечание о сообщениях коммитов. Обладание хорошим руководством по созданию коммитов и следование ему значительно облегчает работу с Git'ом и сотрудничество с другими разработчиками. У проекта Git имеется документ с хорошими советами по созданию коммитов, из которых делаются патчи — прочитать его можно в исходном коде Git в файле `Documentation/SubmittingPatches`.

Во-первых, не стоит отсылать ничего с ошибками в пробельных символах. Git предоставляет простой способ их обнаружения — перед коммитом, запустите `git diff --check`, это определит возможные проблемы и перечислит их вам. Вот пример, в котором я заменил красный цвет терминала символами `X`:

	$ git diff --check
	lib/simplegit.rb:5: trailing whitespace.
	+    @git_dir = File.expand_path(git_dir)XX
	lib/simplegit.rb:7: trailing whitespace.
	+ XXXXXXXXXXX
	lib/simplegit.rb:26: trailing whitespace.
	+    def command(git_cmd)XXXX

Если выполните эту команду перед коммитом, то сможете понять, собираетесь ли вы сделать коммит с раздражающими разработчиков ошибками в пробельных символах.

Далее, старайтесь делать так, чтобы каждый коммит был логически отдельным набором изменений. Если можете, старайтесь делать ваши изменения обозримыми — не стоит писать код все выходные, работая над пятью задачами, а затем отправлять их все в понедельник одним массивным коммитом. Даже если вы не делали коммитов в течение выходных, воспользуйтесь индексом, чтобы разбить свою работу на части, как минимум по одному коммиту для каждой проблемы с полезным сообщением к каждому. Если некоторые из изменений затрагивают один и тот же файл, попробуйте использовать `git add --patch` для индексирования файла по частям (это подробно рассмотрено в Главе 6). Снимок состояния проекта на верхушке ветки будет идентичным, сделаете ли вы один коммит или пять, покуда все ваши изменения добавлены в какой-то момент, так что попытайтесь облегчить жизнь вашим коллегам разработчикам, когда они будут просматривать ваши изменения. При таком подходе будет проще выделить или отменить одно из изменений, если возникнет такая необходимость. В главе 6 описано множество полезных ухищрений для переписывания истории и интерактивного индексирования файлов — пользуйтесь этими инструментами для изготовления ясной и понятной истории.

Последняя вещь, которую стоит иметь в виду, — это сообщение коммита. Написание качественных сообщений коммитов должно войти в привычку, это сделает сотрудничество с использованием Git'а гораздо проще. По общему правилу, ваши сообщения должны начинаться с одной строки не длиннее 50 символов, лаконично описывающей набор изменений, затем пустая строка, затем более детальное описание. Проект Git требует, чтобы детальное объяснение включало в себя мотивацию на изменения и противопоставляло вашу реализацию с предыдущим поведением — это хорошее руководство к действию. Если вы пишите сообщения к коммитам на английском языке, то хорошей идеей является использование повелительного наклонения глаголов в настоящем времени. Другими словами, пишите команды. Вместо "I added tests for" или "Adding tests for" используйте "Add tests for".

Вот шаблон, изначально написанный Тимом Поупом на сайте tpope.net:

	Краткое (до 50 символов) описание изменений

	Более детальное объяснение, если необходимо. Перенос на 72 символе
	или около того. В некоторых контекстах, первая строка рассматривается
	как тема письма, а остальное телом. Пустая строка, отделяющая сводку
	от тела важна (если вы не опустили тело целиком); если вы оставите их
	вместе, инструменты такие, как rebase, могут воспринять это неправильно.

	Дальнейшие параграфы идут после пустых строк

	 - также можно применять маркеры списков

	 - обычно в качестве маркера списка используется дефис или звёздочка,
	   с одним пробелом перед ним и пустыми строками между пунктами,
	   хотя соглашения в этом аспекте могут разниться

Если все ваши сообщения о коммитах будут выглядеть как это, всё будет намного проще для вас и для разработчиков, с которыми вы работаете. Проект Git содержит хорошо отформатированные сообщения о коммитах — я советую вам запустить `git log --no-merges` там, чтобы увидеть, как выглядит хорошо отформатированная история коммитов проекта.

В последующих примерах и почти везде в этой книге для краткости я не форматирую сообщения так красиво, как это; вместо этого я использую опцию `-m` для команды `git commit`. Делайте, как я говорю, а не как я делаю.

### Отдельная маленькая команда ###

Наиболее простой тип организации, с которой вы легко можете столкнуться — частный проект с одним или двумя другими разработчиками. Под термином частный я подразумеваю закрытый код, недоступный для чтения остальному миру. Вы и все остальные разработчики имеете право записи в репозиторий.

В этой среде вы можете придерживаться рабочего процесса, похожего на тот, который вы бы использовали в Subversion или другой централизованной системе. Вы по-прежнему получите такие преимущества, как локальные коммиты (коммиты в offline) и возможность гораздо более простого ветвления и слияния, но сам рабочий процесс может оставаться очень похожим; главное отличие — во время выполнения коммита слияние происходит на стороне клиента, а не на сервере.
Давайте посмотрим, как выглядел бы процесс, когда два разработчика начинают работать вместе с общим репозиторием. Первый разработчик, Джон, клонирует репозиторий, делает изменения и создаёт локальный коммит. (Я заменяю служебные сообщения знаком `...` в этих примерах, чтобы немного их сократить.)

	# Машина Джона
	$ git clone john@githost:simplegit.git
	Initialized empty Git repository in /home/john/simplegit/.git/
	...
	$ cd simplegit/
	$ vim lib/simplegit.rb 
	$ git commit -am 'removed invalid default value'
	[master 738ee87] removed invalid default value
	 1 files changed, 1 insertions(+), 1 deletions(-)

Второй разработчик, Джессика, выполняет то же самое — клонирует репозиторий и делает коммит с изменениями:

	# Машина Джессики
	$ git clone jessica@githost:simplegit.git
	Initialized empty Git repository in /home/jessica/simplegit/.git/
	...
	$ cd simplegit/
	$ vim TODO 
	$ git commit -am 'add reset task'
	[master fbff5bc] add reset task
	 1 files changed, 1 insertions(+), 0 deletions(-)

Теперь Джессика отправляет свою работу на сервер:

	# Машина Джессики
	$ git push origin master
	...
	To jessica@githost:simplegit.git
	   1edee6b..fbff5bc  master -> master

Джон также пытается выложить свои изменения:

	# Машина Джона
	$ git push origin master
	To john@githost:simplegit.git
	 ! [rejected]        master -> master (non-fast forward)
	error: failed to push some refs to 'john@githost:simplegit.git'

Джон не может выполнить отправку изменений, так как за это время Джессика уже отправила свои. Это очень важно понять, особенно если вы привыкли к Subversion, так как мы видим, что эти два разработчика не редактировали один и тот же файл. Хотя Subversion и выполняет автоматическое слияние на сервере, если редактировались разные файлы, при использовании Git вы должны слить коммиты локально. Прежде чем Джон сможет отправить свои изменения на сервер, он должен извлечь наработки Джессики и выполнить слияние:

	$ git fetch origin
	...
	From john@githost:simplegit
	 + 049d078...fbff5bc master     -> origin/master

На этот момент, локальный репозиторий Джона выглядит так, как показано на Рисунке 5-4.

Insert 18333fig0504.png
Рисунок 5-4. Исходный репозиторий Джона.

У Джона есть ссылка на изменения, выложенные Джессикой, и он должен слить их со своей работой перед тем, как ему разрешат её отправить:

	$ git merge origin/master
	Merge made by recursive.
	 TODO |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)

Слияние прошло без проблем — история коммитов Джона теперь выглядит как на Рисунке 5-5.

Insert 18333fig0505.png
Рисунок 5-5. Репозиторий Джона после слияния с origin/master.

Теперь Джон может протестировать свой код, дабы удостовериться, что он по-прежнему работает нормально, а затем выложить свою работу, уже объединённую с работой Джессики, на сервер:

	$ git push origin master
	...
	To john@githost:simplegit.git
	   fbff5bc..72bbc59  master -> master

В результате история коммитов Джона выглядит, как показано на Рисунке 5-6.

Insert 18333fig0506.png 
Рисунок 5-6. История коммитов Джона после отправки изменений на сервер.

Тем временем, Джессика работала над тематической веткой. Она создала тематическую ветку с названием `issue54` и сделала три коммита в этой ветке. Она ещё не извлекала изменения Джона, так что её история коммитов выглядит, как показано на Рисунке 5-7.

Insert 18333fig0507.png
Рисунок 5-7. Исходная история коммитов Джессики.

Джессика хочет синхронизировать свою работу с Джоном, так что она извлекает изменения с сервера:

	# Машина Джессики
	$ git fetch origin
	...
	From jessica@githost:simplegit
	   fbff5bc..72bbc59  master     -> origin/master

Эта команда извлекает наработки Джона, которые он успел выложить. История коммитов Джессики теперь выглядит как на Рисунке 5-8.

Insert 18333fig0508.png
Рисунок 5-8. История коммитов Джессики после извлечения изменений Джона.

Джессика полагает, что её тематическая ветка закончена, но она хочет узнать, с чем ей нужно слить свою работу, чтобы она могла выложить её на сервер. Она запускает `git log`, чтобы выяснить это:

	$ git log --no-merges origin/master ^issue54
	commit 738ee872852dfaa9d6634e0dea7a324040193016
	Author: John Smith <jsmith@example.com>
	Date:   Fri May 29 16:01:27 2009 -0700

	    removed invalid default value

Теперь Джессика может слить свою тематическую ветку в ветку `master`, слить работу Джона (`origin/master`) в свою ветку `master` и затем отправить изменения на сервер. Сначала она переключается на свою основную ветку, чтобы объединить всю эту работу:

	$ git checkout master
	Switched to branch "master"
	Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.

Она может слить сначала ветку `origin/master`, а может и `issue54` — обе они находятся выше в истории коммитов, так что не важно какой порядок слияния она выберет. Конечное состояние репозитория должно получиться идентичным независимо от того, какой порядок слияния она выберет; только история коммитов будет немного разная. Она решает слить ветку `issue54` первой:

	$ git merge issue54
	Updating fbff5bc..4af4298
	Fast forward
	 README           |    1 +
	 lib/simplegit.rb |    6 +++++-
	 2 files changed, 6 insertions(+), 1 deletions(-)

Никаких проблем не возникло; как видите, это был обычная перемотка. Теперь Джессика сливает работу Джона (`origin/master`):

	$ git merge origin/master
	Auto-merging lib/simplegit.rb
	Merge made by recursive.
	 lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)

Слияние проходит нормально, и теперь история коммитов Джессики выглядит так, как показано на Рисунке 5-9.

Insert 18333fig0509.png
Рисунок 5-9. История коммитов Джессики после слияния с изменениями Джона.

Теперь указатель `origin/master` доступен из ветки `master` Джессики, так что она может спокойно выполнить `git push` (полагая, что Джон не выкладывал свои изменения за это время):

	$ git push origin master
	...
	To jessica@githost:simplegit.git
	   72bbc59..8059c15  master -> master

Каждый разработчик несколько раз выполнял коммиты и успешно сливал свою работу с работой другого; смотри Рисунок 5-10.

Insert 18333fig0510.png
Рисунок 5-10. История коммитов Джессики после отправки всех изменений обратно на сервер.

Это один из простейших рабочих процессов. Вы работаете некоторое время, преимущественно в тематической ветке, и, когда приходит время, сливаете её в свою ветку `master`. Когда вы готовы поделиться этой работой с другими, вы сливаете её в ветку `master`, извлекаете изменения с сервера и сливаете `origin/master` (если за это время произошли изменения), и, наконец, отправляете свои изменения в ветку `master` на сервер. Общая последовательность действий выглядит так, как показано на Рисунке 5-11.

Insert 18333fig0511.png
Рисунок 5-11. Общая последовательность событий для простого рабочего процесса с несколькими разработчиками в Git'е.

### Отдельная команда с менеджером ###

В этом сценарии мы рассмотрим роли участников проекта в закрытых группах большего размера. Вы научитесь работе в окружении, где маленькие группы совместно работают над задачами, а затем результаты их деятельности интегрируются отдельным субъектом.

Давайте представим, что Джон и Джессика работают вместе над одной задачей, в то время как Джессика с Джози работают над другой. В этом случае компания использует рабочий процесс с менеджером по интеграции, при котором работа частных групп объединяется только определёнными инженерами (обновление ветки `master` главного репозитория может осуществляться только этими инженерами). В этом случае вся работа выполняется в ветках отдельных команд разработчиков и впоследствии объединяется воедино менеджерами по интеграции.

Давайте проследим за рабочим процессом Джессики, которая работает над двумя задачами, сотрудничая одновременно с двумя разными разработчиками. Положим, что она уже имеет свою собственную копию репозитория. Джессика решает сначала взяться за задачу `featureA`. Для этого она создаёт новую ветку и выполняет в ней некоторую работу:

	# Машина Джессики
	$ git checkout -b featureA
	Switched to a new branch "featureA"
	$ vim lib/simplegit.rb
	$ git commit -am 'add limit to log function'
	[featureA 3300904] add limit to log function
	 1 files changed, 1 insertions(+), 1 deletions(-)

На этом этапе ей требуется поделиться своей работой с Джоном, так что она отправляет коммиты, выполненные на ветке `featureA`, на сервер. Так как Джессика не имеет право на изменение ветки `master` на сервере — только менеджеры по интеграции могут делать это — она вынуждена отправлять свои изменения в другую ветку, чтобы обмениваться работой с Джоном:

	$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	 * [new branch]      featureA -> featureA

Джессика сообщает по электронной почте Джону, что она выложила некоторые наработки в ветку `featureA`, и что он может проверить их. Пока Джессика ждёт ответа от Джона, она решает начать работу над веткой `featureB` вместе с Джози. Для начала она создаёт новую ветку для этой задачи, используя в качестве основы ветку `master` на сервере:

	# Машина Джессики
	$ git fetch origin
	$ git checkout -b featureB origin/master
	Switched to a new branch "featureB"

Теперь Джессика делает пару коммитов в ветке `featureB`:

	$ vim lib/simplegit.rb
	$ git commit -am 'made the ls-tree function recursive'
	[featureB e5b0fdc] made the ls-tree function recursive
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ vim lib/simplegit.rb
	$ git commit -am 'add ls-files'
	[featureB 8512791] add ls-files
	 1 files changed, 5 insertions(+), 0 deletions(-)

Репозиторий Джессики выглядит, как показано на Рисунке 5-12.

Insert 18333fig0512.png
Рисунок 5-12. Исходная история коммитов у Джессики.

Джессика уже готова отправить свою работу на сервер, но получает от Джози сообщение о том, что некоторые наработки уже были выложены на сервер в ветку `featureBee`. Поэтому Джессика должна сначала слить эти изменения со своими, прежде чем она сможет отправить свою работу на сервер. Она может извлечь изменения Джози командой `git fetch`:

	$ git fetch origin
	...
	From jessica@githost:simplegit
	 * [new branch]      featureBee -> origin/featureBee

Теперь Джессика может слить эти изменения в свои наработки командой `git merge`:

	$ git merge origin/featureBee
	Auto-merging lib/simplegit.rb
	Merge made by recursive.
	 lib/simplegit.rb |    4 ++++
	 1 files changed, 4 insertions(+), 0 deletions(-)

Есть небольшая проблема — ей нужно выложить изменения из своей ветки `featureB` в ветку `featureBee` на сервере. Она может сделать это при помощи команды `git push`, указав название локальной и удалённой ветки, разделённые двоеточием:

	$ git push origin featureB:featureBee
	...
	To jessica@githost:simplegit.git
	   fba9af8..cd685d1  featureB -> featureBee

Это называется _refspec_. Смотри Главу 9, где более детально обсуждаются спецификации ссылок и различные вещи, которые вы можете делать с ними.

Далее, Джон сообщает Джессике по почте, что он добавил некоторые изменения в ветку `featureA` и просит её проверить их. Она выполняет `git fetch`, чтобы получить внесённые Джоном изменения:

	$ git fetch origin
	...
	From jessica@githost:simplegit
	   3300904..aad881d  featureA   -> origin/featureA

Затем, используя команду `git log`, она смотрит, что же было изменено:

	$ git log origin/featureA ^featureA
	commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
	Author: John Smith <jsmith@example.com>
	Date:   Fri May 29 19:57:33 2009 -0700

	    changed log output to 30 from 25

Наконец, она сливает работу Джона в свою собственную ветку `featureA`:

	$ git checkout featureA
	Switched to branch "featureA"
	$ git merge origin/featureA
	Updating 3300904..aad881d
	Fast forward
	 lib/simplegit.rb |   10 +++++++++-
	1 files changed, 9 insertions(+), 1 deletions(-)

Джессика хочет кое-что подправить, так что она опять делает коммит и затем отправляет изменения на сервер:

	$ git commit -am 'small tweak'
	[featureA ed774b3] small tweak
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	   3300904..ed774b3  featureA -> featureA

История коммитов Джессики теперь выглядит так, как показано на Рисунке 5-13.

Insert 18333fig0513.png
Рисунок 5-13. История Джессики после внесения коммитов в ветку с решаемой задачей.

Джессика, Джози и Джон информируют менеджеров по интеграции, что ветки `featureA` и `featureBee` на сервере готовы к интеграции в основную ветку разработки. После того, как они интегрируют эти ветки в основную версию, извлечение данных с сервера приведёт к появлению новых коммитов слияния. Таким образом, история коммитов станет выглядеть так, как на Рисунке 5-14.

Insert 18333fig0514.png
Рисунок 5-14. История коммитов Джессики после слияния двух тематических веток.

Множество групп переходят на Git именно из-за возможности параллельной работы нескольких команд с последующим объединением разных линий разработки. Огромное преимущество Git'а — возможность маленьких подгрупп большой команды работать вместе через удалённые ветки, не мешая при этом всей команде. Последовательность событий в рассмотренном здесь рабочем процессе представлена на Рисунке 5-15.

Insert 18333fig0515.png
Рисунок 5-15. Основная последовательность действий для рабочего процесса в команде с менеджером по интеграции.

### Небольшой открытый проект ###

Внести вклад в открытый проект — это немного другое. Из-за того, что у вас нет прав на прямое изменение веток проекта, требуется какой-нибудь другой путь для обмена наработками с мейнтейнерами. Первый пример описывает участие в проекте через разветвление (fork) на Git-хостингах, на которых это делается достаточно просто. Сайты repo.or.cz и GitHub оба поддерживают такую возможность, и большая часть мейнтейнеров проектов придерживаются такого способа сотрудничества. В следующем разделе рассматриваются проекты, которые предпочитают принимать патчи по e-mail.

Сначала вы скорее всего захотите склонировать основной репозиторий, создать тематическую ветку для одного или нескольких патчей, которые вы собираетесь внести в проект, и выполнить свою работу в ней. Последовательность действий выглядит следующим образом:

	$ git clone (url)
	$ cd project
	$ git checkout -b featureA
	$ (выполнение работы)
	$ git commit
	$ (выполнение работы)
	$ git commit

Возможно, у вас возникнет желание воспользоваться `rebase -i`, чтобы сплющить (squash) свои наработки в единый коммит, или реорганизовать наработки в коммитах таким образом, чтобы их было проще воспринимать мейнтейнерам проекта — об интерактивном перемещении будет рассказано в Главе 6.

Если вы закончили работу со своей веткой и готовы поделиться наработками с мейнтейнерами, перейдите на страницу исходного проекта и нажмите кнопку "Fork", создав таким образом свою собственную копию проекта доступную на запись. Затем вам нужно добавить URL этого нового репозитория в список удалённых репозиториев, в нашем случае мы назовём его `myfork`:

	$ git remote add myfork (url)

Вам нужно отправить свои наработки в этот репозиторий. Проще всего будет отправить в удалённый репозиторий ту ветку, над которой вы работаете, а не сливать её в ветку `master` и отправлять потом его. Это объясняется следующим образом — если ваша работа не будет принята или будет принята только частично, вам не придётся откатывать назад свою ветку `master`. Если мейнтейнеры сольют, переместят или частично включат вашу работу, вы, в конечном счёте, получите её обратно при получении изменений из их репозитория:

	$ git push myfork featureA

Когда ваши наработки будут отправлены в ваш форк, вам нужно будет послать уведомление мейнтейнеру. Его часто называют запросом на включение (pull request), вы можете либо сгенерировать его через сайт — на GitHub'е есть кнопка "pull request", автоматически уведомляющая мейнтейнера, либо выполнить команду `git request-pull` и вручную отправить её вывод по почте мейнтейнеру.

Команда `request-pull` принимает в качестве аргумента имя базовой ветки, в которую вы хотите включить свою работу, и URL репозитория, из которого мейнтейнер может получить ваши наработки. Команда выводит короткую сводку всех изменений, которые вы просите включить в проект. Например, если Джессика хочет послать Джону запрос на включение, когда она сделала пару коммитов в тематической ветке и уже отправила её на сервер, ей следует выполнить следующее:

	$ git request-pull origin/master myfork
	The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
	  John Smith (1):
	        added a new function

	are available in the git repository at:

	  git://githost/simplegit.git featureA

	Jessica Smith (2):
	      add limit to log function
	      change log output to 30 from 25

	 lib/simplegit.rb |   10 +++++++++-
	 1 files changed, 9 insertions(+), 1 deletions(-)

Вывод может быть отправлен мейнтейнеру — он содержит список коммитов, информацию о том, где начинается ветка с изменениями, и указывает откуда можно забрать эти изменения.

Для проекта, мейнтейнером которого вы не являетесь, проще иметь ветку `master`, которая отслеживает ветку `origin/master`, и выполнять работу в тематических ветках, которые вы легко сможете удалить, в случае если они будут отклонены. Если вы распределяете свои наработки по различным темам в тематических ветках, вам будет проще выполнить перемещение своей работы, в случае если верхушка главного репозитория переместится за время работы и ваши коммиты уже не получится применить без конфликтов. Например, если вы планирует отправить в проект работу по другой теме, не продолжайте работать внутри тематической ветки, которую вы только что отправили, начните снова с ветки `master` главного репозитория:

	$ git checkout -b featureB origin/master
	$ (выполнение работы)
	$ git commit
	$ git push myfork featureB
	$ (отправка письма мейнтейнеру)
	$ git fetch origin

Теперь каждая из ваших тем представляет собой нечто похожее на очередь из патчей, которую вы можете перезаписывать, перемещать, модифицировать, не оказывая влияние на остальные, как на Рисунке 5-16.

Insert 18333fig0516.png
Рисунок 5-16. Исходная история коммитов при работе над featureB.

Давайте представим, что мейнтейнер проекта включил в основную версию чью-то группу патчей. Затем он попытался включить вашу первую ветку, но слияние уже не проходит гладко. В этом случае вы можете попробовать переместить эту ветку на верхушку ветки `origin/master`, разрешить конфликты для мейнтейнера и затем заново представить свои изменения на рассмотрение:

	$ git checkout featureA
	$ git rebase origin/master
	$ git push -f myfork featureA

Так вы перепишете свою историю коммитов, чтобы она выглядела так, как на Рисунке 5-17.

Insert 18333fig0517.png
Рисунок 5-17. История коммитов после работы в featureA.

Так как вы переместили ветку, команде push вы должны передать опцию `-f`, чтобы иметь возможность заменить ветку `featureA` на сервере. Есть альтернатива — выложить новую работу на сервер в другую ветку (возможно, назвав её `featureAv2`).

Давайте рассмотрим более вероятный сценарий: мейнтейнер просмотрел на вашу работу во второй ветке и ему понравилась ваша идея, но он хотел бы, чтобы вы изменили некоторые детали реализации. Воспользуемся этой возможностью, чтобы заодно переместить вашу работу так, чтобы она базировалась на текущей версии ветки `master` в проекте. Создадим новую ветку, базирующуюся на текущей ветке `origin/master`, уплотним (squash) здесь изменения из ветки `featureB`, разрешим все конфликты, которые могут возникнуть, сделаем необходимые изменения в реализации вашей идеи и затем выложим всё это в виде новой ветки:

	$ git checkout -b featureBv2 origin/master
	$ git merge --no-commit --squash featureB
	$ (изменение реализации)
	$ git commit
	$ git push myfork featureBv2

Опция `--squash` берёт всю работу на сливаемой ветке (featureB) и сжимает её в один коммит, не являющийся коммитом-слиянием, и помещает его на верхушку текущей ветки. Опция `--no-commit` сообщает Git'у, что не нужно автоматически записывать коммит. Это позволит вам внести все изменения с другой ветки и затем сделать ещё ряд изменений перед записью нового коммита.

Теперь вы можете отправить мейнтейнеру сообщение о том, что вы сделали требуемые изменения, и они могут быть найдены в вашей ветке `featureBv2` (смотри Рисунок 5-18).

Insert 18333fig0518.png
Рисунок 5-18. История коммитов после работы над featureBv2.

### Большой открытый проект ###

Во многих крупных проектах есть установленные процедуры принятия патчей — вам потребуется выяснить точные правила для каждого проекта отдельно, так как они везде разные. Однако, многие крупные открытые проекты принимают патчи через списки рассылки для разработчиков, так что мы сейчас рассмотрим пример использования этого способа.

Рабочий процесс похож на описанный ранее — вы создаёте тематическую ветку для каждой серии патчей, над которой работаете. Отличие состоит в процессе внесения этих изменений в проект. Вместо того, чтобы создавать ответвление (fork) от проекта и отправлять наработки в свой собственный репозиторий с правами на запись, вы генерируете e-mail версию каждой серии коммитов и отправляете её в список рассылки для разработчиков:

	$ git checkout -b topicA
	$ (выполнение работы)
	$ git commit
	$ (выполнение работы)
	$ git commit

Теперь у нас есть два коммита, которые теперь нужно отправить в список рассылки. Воспользуемся командой `git format-patch`, чтобы сгенерировать файлы в формате mbox, которые вы сможете отправить по почте. Эта команда превращает каждый коммит в электронное письмо, темой которого является первая строка сообщения коммита, а оставшаяся часть сообщения коммита и патч, который он представляет, являются телом письма. Хорошей особенностью этого является то, что применение патча из сгенерированного командой `format-patch` электронного письма сохраняет всю информацию о коммите. Мы увидим это в следующем разделе, когда будем применять такие патчи:

	$ git format-patch -M origin/master
	0001-add-limit-to-log-function.patch
	0002-changed-log-output-to-30-from-25.patch

Команда `format-patch` создаёт файлы с патчами и выводит их названия. Опция `-M` сообщает Git'у о необходимости отслеживания переименований файлов. Итоговые патчи выглядят так:

	$ cat 0001-add-limit-to-log-function.patch 
	From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
	From: Jessica Smith <jessica@example.com>
	Date: Sun, 6 Apr 2008 10:17:23 -0700
	Subject: [PATCH 1/2] add limit to log function

	Limit log functionality to the first 20

	---
	 lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)

	diff --git a/lib/simplegit.rb b/lib/simplegit.rb
	index 76f47bc..f9815f1 100644
	--- a/lib/simplegit.rb
	+++ b/lib/simplegit.rb
	@@ -14,7 +14,7 @@ class SimpleGit
	   end

	   def log(treeish = 'master')
	-    command("git log #{treeish}")
	+    command("git log -n 20 #{treeish}")
	   end

	   def ls_tree(treeish = 'master')
	-- 
	1.6.2.rc1.20.g8c5b.dirty

Вы также можете отредактировать эти файлы с патчами, чтобы добавить в электронное письмо какую-то информацию, которую вы не хотите показывать в сообщении коммита. Если вы добавите текст между строкой `--` и началом патча (строка `lib/simplegit.rb`), то разработчик сможет его прочитать, а при применении патча он будет выброшен.

Чтобы отправить эти файлы в список рассылки, вы можете либо вставить файл в своём почтовом клиенте, либо отправить его через специальную программу из командной строки. Вставка текста часто приводит к ошибкам форматирования, особенно в "умных" клиентах, которые не сохраняют символы перевода строки и пробельные символы в исходном виде. К счастью, Git предоставляет инструмент, позволяющий вам передавать через IMAP правильно отформатированные патчи. Для вас применение этого инструмента может оказаться более простым. Я покажу как отсылать патчи через Gmail, так как именно этот агент я и использую; вы можете прочесть подробные инструкции для множества почтовых программ в вышеупомянутом файле `Documentation/SubmittingPatches`, находящемся в исходном коде Git'а.

Для начала нам необходимо настроить секцию imap в файле `~/.gitconfig`. Можете добавить все значения по одному несколькими командами `git config`, или можете добавить их все сразу вручную; но в итоге ваш файл конфигурации должен выглядеть примерно так:

	[imap]
	  folder = "[Gmail]/Drafts"
	  host = imaps://imap.gmail.com
	  user = user@gmail.com
	  pass = p4ssw0rd
	  port = 993
	  sslverify = false

Если ваш IMAP-сервер не использует SSL, две последние строки могут отсутствовать, а параметр host примет значение `imap://` вместо `imaps://`.
Когда закончите с настройками, воспользуйтесь командой `git send-email`, чтобы поместить свою серию патчей в папку Drafts на указанном IMAP-сервере:

	$ git send-email *.patch
	0001-added-limit-to-log-function.patch
	0002-changed-log-output-to-30-from-25.patch
	Who should the emails appear to be from? [Jessica Smith <jessica@example.com>] 
	Emails will be sent from: Jessica Smith <jessica@example.com>
	Who should the emails be sent to? jessica@example.com
	Message-ID to be used as In-Reply-To for the first email? y

Затем Git выдаёт кучу служебных сообщений, которые для каждого отсылаемого патча выглядят следующим образом:

	(mbox) Adding cc: Jessica Smith <jessica@example.com> from 
	  \line 'From: Jessica Smith <jessica@example.com>'
	OK. Log says:
	Sendmail: /usr/sbin/sendmail -i jessica@example.com
	From: Jessica Smith <jessica@example.com>
	To: jessica@example.com
	Subject: [PATCH 1/2] added limit to log function
	Date: Sat, 30 May 2009 13:29:15 -0700
	Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
	X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
	In-Reply-To: <y>
	References: <y>

	Result: OK

Если всё прошло успешно, то сейчас вы можете перейти в свою папку Drafts, изменить поле 'To' на адрес списка рассылки, в который вы собираетесь послать патчи, возможно, указать адрес мейнтейнера или лица отвечающую за нужную часть проекта в поле 'CC' и отправить сообщение.

### Итоги ###

В этом разделе мы рассмотрели ряд общепринятых рабочих процессов, применяемых в разных типах проектов использующих Git, c которыми вы наверняка столкнётесь. Также были представлены несколько новых инструментов, призванных помочь вам в организации этих процессов. Далее мы рассмотрим, как осуществляется работа с противоположной стороны баррикады — как сопровождать проект использующий Git. Вы научитесь роли благосклонного диктатора или роли менеджера по интеграции.

## Поддержка проекта ##

## Maintaining a Project ##

В дополнение к тому, как эффективно работать над проектом, вам, наверняка, необходимо также знать как самому поддерживать проект. Поддержка проекта может заключаться в принятии и применении патчей, сгенерированных с помощью 'format-patch' и отправленных вам по почте или в интеграции изменений из веток тех репозиториев, которые вы добавили в качестве удаленных (remotes) для вашего проекта. Неважно, поддерживаете ли вы стандартный репозиторий проекта или хотите помочь с проверкой или утверждением патчей, вам необходимо выработать метод приема наработок, который будет наиболее доступным для других участников и не будет изменяться вами в течении длительного срока.

In addition to knowing how to effectively contribute to a project, you’ll likely need to know how to maintain one. This can consist of accepting and applying patches generated via `format-patch` and e-mailed to you, or integrating changes in remote branches for repositories you’ve added as remotes to your project. Whether you maintain a canonical repository or want to help by verifying or approving patches, you need to know how to accept work in a way that is clearest for other contributors and sustainable by you over the long run.

### Работа с тематическими ветками ###

### Working in Topic Branches ###

Когда вы решаете интегрировать новую наработку, хорошей идеей, обычно, является опробовать ее в тематической ветке - временной ветке, специально созданной для тестирования наработки. В этом случае  легко изменять код патча индивидуально и приостанавливать работу, если что-то не работает как положено, до тех пор, пока у вас не появится время на ее возобновление. Если вы выбираете для ветки простое имя, основанное на теме вашей работы, например, `ruby_client`, или что-то аналогичное по описанию, то вы сможете легко вспомнить, зачем нужна данная ветка, если вам вдруг придется отложить работу и вернуться к ней позднее. В Git, мейнтейнер проекта, как правило, создает ветки с указанием пространства имен — к примеру, 'sc/ruby_client', где 'sc' есть никнейм автора, который вносит изменения.
Как вы уже знаете, вы можете создать ветку, основанную на вашей главной ветке, следующим образом:

When you’re thinking of integrating new work, it’s generally a good idea to try it out in a topic branch — a temporary branch specifically made to try out that new work. This way, it’s easy to tweak a patch individually and leave it if it’s not working until you have time to come back to it. If you create a simple branch name based on the theme of the work you’re going to try, such as `ruby_client` or something similarly descriptive, you can easily remember it if you have to abandon it for a while and come back later. The maintainer of the Git project tends to namespace these branches as well — such as `sc/ruby_client`, where `sc` is short for the person who contributed the work. 
As you’ll remember, you can create the branch based off your master branch like this:

	$ git branch sc/ruby_client master

Или, если вы хотите сразу переключиться на создаваемую ветку, вы можете использовать опцию `checkout -b`:

Or, if you want to also switch to it immediately, you can use the `checkout -b` option:

	$ git checkout -b sc/ruby_client master

Теперь вы готовы к тому, чтобы принять изменения в данную тематическую ветку и определить, хотите ли вы влить ее в ваши 'более постоянные' ветки.

Now you’re ready to add your contributed work into this topic branch and determine if you want to merge it into your longer-term branches.

### Применение патчей, отправленных по почте ###

### Applying Patches from E-mail ###

Если вы принимаете патч, который вы должны интегрировать в ваш проект, через электронную почту, то вам потребуется применить патч в вашей тематической ветке, чтобы протестировать его. Есть два способа применения отправленных по почте патчей: при помощи команды `git apply` или команды `git am`.

If you receive a patch over e-mail that you need to integrate into your project, you need to apply the patch in your topic branch to evaluate it. There are two ways to apply an e-mailed patch: with `git apply` or with `git am`.

#### Применение патчей с помощью команды apply ####

#### Applying a Patch with apply ####

Если вы приняли патч, который сгенерировали с помощью команды `git diff` или Unix-команды `diff`, вы можете применить его при помощи команды `git apply`. Полагая, что вы сохранили патч в `/tmp/patch-ruby-client.patch`, вы можете применить его следующим образом:

If you received the patch from someone who generated it with the `git diff` or a Unix `diff` command, you can apply it with the `git apply` command. Assuming you saved the patch at `/tmp/patch-ruby-client.patch`, you can apply the patch like this:

	$ git apply /tmp/patch-ruby-client.patch

Эта команда изменяет файлы в вашей рабочей директории. Это практически идентично выполнению команды `patch -p1` для применения патча, хотя `git apply` является более параноидальной по сравнению с командой `patch`. Она также выполняет добавление, удаление и переименование файлов, если они описаны в `git diff`, чего не сделает команда `patch`. В конечном счете, `git apply` реализует модель `применить все, или отменить все`, в которой либо принимается все, либо вообще ничего, тогда как `patch` позволяет частично применять патч-файлы, оставляя вашу директорию в странном и непонятном состоянии. Команда `git apply` в целом более параноидальна, чем `patch`. Она не создаст для вас коммит — после выполнения команды вы должны вручную проиндексировать внесенные изменения и выполнить коммит.

This modifies the files in your working directory. It’s almost identical to running a `patch -p1` command to apply the patch, although it’s more paranoid and accepts fewer fuzzy matches than patch. It also handles file adds, deletes, and renames if they’re described in the `git diff` format, which `patch` won’t do. Finally, `git apply` is an "apply all or abort all" model where either everything is applied or nothing is, whereas `patch` can partially apply patchfiles, leaving your working directory in a weird state. `git apply` is overall much more paranoid than `patch`. It won’t create a commit for you — after running it, you must stage and commit the changes introduced manually.

Перед применением патча вы также можете использовать `apply` чтобы убедиться, что патч применяется без ошибок — для этого выполните `git apply --check`, указав нужный патч:

You can also use git apply to see if a patch applies cleanly before you try actually applying it — you can run `git apply --check` with the patch:

	$ git apply --check 0001-seeing-if-this-helps-the-gem.patch 
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply

Если выполнение этой команды ничего не выводит на экран, то патч должен быть применен без ошибок. Если проверка оборачивается неудачей, то команда устанавливает на выходе не нулевой статус, так что вы можете использовать ее при написании скриптов.

If there is no output, then the patch should apply cleanly. This command also exits with a non-zero status if the check fails, so you can use it in scripts if you want.

#### Применение патчей с помощью команды am ####

#### Applying a Patch with am ####

Если разработчик является пользователем Git и применял команду `format-patch` для создания своего патча, то ваша задача оказывается более простой, так как патч содержит информацию об авторе и сообщение коммита. Если есть такая возможность — поощряйте участников проекта на использование команды `format-patch` вместо `diff` при генерировании патчей для вас. Вы должны использовать `git apply` только если нет другого выхода и патчи уже созданы при помощи `diff`.

If the contributor is a Git user and was good enough to use the `format-patch` command to generate their patch, then your job is easier because the patch contains author information and a commit message for you. If you can, encourage your contributors to use `format-patch` instead of `diff` to generate patches for you. You should only have to use `git apply` for legacy patches and things like that.

Чтобы применить патч, созданный при помощи `format-patch`, используйте команду `git am`. С технической точки зрения, `git am` читает mbox-файл, который является простым текстовым форматом для хранения одного или более e-mail сообщений в одном текстовом файле. Он выглядит примерно следующим образом:

To apply a patch generated by `format-patch`, you use `git am`. Technically, `git am` is built to read an mbox file, which is a simple, plain-text format for storing one or more e-mail messages in one text file. It looks something like this:

	From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
	From: Jessica Smith <jessica@example.com>
	Date: Sun, 6 Apr 2008 10:17:23 -0700
	Subject: [PATCH 1/2] add limit to log function

	Limit log functionality to the first 20

Это начало вывода команды `format-patch`, которую вы видели в предыдущем разделе. Это одновременно и правильный mbox формат для e-mail. Если кто-либо отправил вам по почте патч, использовав при этом надлежащим образом команду `git send-email`, и вы сохраняете это сообщение в mbox формате, то вы можете затем указать этот mbox-файл в команде `git am` — в результате команда начнет применять все патчи, которые будут описаны в этом файле. Если вы используете почтовый клиент, который способен сохранять несколько e-mail сообщений в один mbox-файл, то вы можете сохранить всю серию патчей в один файл и затем использовать команду `git am` для применения всех патчей сразу.

This is the beginning of the output of the format-patch command that you saw in the previous section. This is also a valid mbox e-mail format. If someone has e-mailed you the patch properly using git send-email, and you download that into an mbox format, then you can point git am to that mbox file, and it will start applying all the patches it sees. If you run a mail client that can save several e-mails out in mbox format, you can save entire patch series into a file and then use git am to apply them one at a time. 

Однако, если кто-либо загрузил созданный через команду `format-patch` патч-файл в тикет-систему или что-либо подобное, вы можете сохранить файл локально и затем передать его команде `git am` для применения патча:

However, if someone uploaded a patch file generated via `format-patch` to a ticketing system or something similar, you can save the file locally and then pass that file saved on your disk to `git am` to apply it:

	$ git am 0001-limit-log-function.patch 
	Applying: add limit to log function

Вы видите, что патч был применен без ошибок и автоматически был создан коммит. Информация об авторе, берется из полей `From` и `Date` e-mail сообщения, а сообщение коммита извлекается из поля `Subject` и тела (до начала самого патча) e-mail сообщения. Например, если этот патч был применен из mbox-файла приведенного выше примера, созданный коммит будет выглядеть примерно следующим образом:

You can see that it applied cleanly and automatically created the new commit for you. The author information is taken from the e-mail’s `From` and `Date` headers, and the message of the commit is taken from the `Subject` and body (before the patch) of the e-mail. For example, if this patch was applied from the mbox example I just showed, the commit generated would look something like this:

	$ git log --pretty=fuller -1
	commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
	Author:     Jessica Smith <jessica@example.com>
	AuthorDate: Sun Apr 6 10:17:23 2008 -0700
	Commit:     Scott Chacon <schacon@gmail.com>
	CommitDate: Thu Apr 9 09:19:06 2009 -0700

	   add limit to log function

	   Limit log functionality to the first 20

Информация `Commit` определяет человека, который применил патч и время, когда он был применен. Информация `Author` определяет человека, который в оригинале создал патч и время его создания.

The `Commit` information indicates the person who applied the patch and the time it was applied. The `Author` information is the individual who originally created the patch and when it was originally created. 

Однако возможна ситуация, когда патч не будет применен без ошибок. Возможно ваша основная ветка слишком далеко ушла вперед относительно той, на которой был основан патч, или патч имеет зависимость от другого патча, который вы еще не применили. В этом случае выполнение команды `git am` будет приостановлено, а у вас спросят, что вы хотите сделать:

But it’s possible that the patch won’t apply cleanly. Perhaps your main branch has diverged too far from the branch the patch was built from, or the patch depends on another patch you haven’t applied yet. In that case, the `git am` process will fail and ask you what you want to do:

	$ git am 0001-seeing-if-this-helps-the-gem.patch 
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Patch failed at 0001.
	When you have resolved this problem run "git am --resolved".
	If you would prefer to skip this patch, instead run "git am --skip".
	To restore the original branch and stop patching run "git am --abort".

Эта команда расставляет отметки о конфликтах в каждый файл, в котором они встречаются; это похоже на то, что происходит при операции слияния или перемещения с конфликтами. Вы разрешаете данную ситуацию похожим образом — редактируете файл, чтобы разрешить конфликт, индексируете новый файл, а затем выполняете команду `git am --resolved`, чтобы начать работу с новым патчем: 

This command puts conflict markers in any files it has issues with, much like a conflicted merge or rebase operation. You solve this issue much the same way — edit the file to resolve the conflict, stage the new file, and then run `git am --resolved` to continue to the next patch:

	$ (fix the file)
	$ git add ticgit.gemspec 
	$ git am --resolved
	Applying: seeing if this helps the gem

Если вы хотите, чтобы Git попытался более умно разрешить конфликт, вы можете использовать опцию `-3`, которая указывает Git-у применять трехходовую операцию слияния. Эта опция не включена по-умолчанию, так как она не работает в случае, если коммит, на котором был основан патч, не находится в вашем репозитории. Если вы все же имеете этот коммит — в случае, когда патч был основан на публичном коммите — опция `-3` позволяет гораздо умнее применять патчи с конфликтами:

If you want Git to try a bit more intelligently to resolve the conflict, you can pass a `-3` option to it, which makes Git attempt a three-way merge. This option isn’t on by default because it doesn’t work if the commit the patch says it was based on isn’t in your repository. If you do have that commit — if the patch was based on a public commit — then the `-3` option is generally much smarter about applying a conflicting patch:

	$ git am -3 0001-seeing-if-this-helps-the-gem.patch 
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Using index info to reconstruct a base tree...
	Falling back to patching base and 3-way merge...
	No changes -- Patch already applied.


В этом случае я пытался применить патч, который я уже применил. Без опции `-3` это привело бы к конфликту.
In this case, I was trying to apply a patch I had already applied. Without the `-3` option, it looks like a conflict.

Если вы применяете серию патчей из mbox-файла, вы также можете запустить команду `am` в интерактивном режиме —  в этом случае команда останавливает свое выполнение после каждого найденного патча и спрашивает вас о необходимости его применения:

If you’re applying a number of patches from an mbox, you can also run the `am` command in interactive mode, which stops at each patch it finds and asks if you want to apply it:

	$ git am -3 -i mbox
	Commit Body is:
	--------------------------
	seeing if this helps the gem
	--------------------------
	Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all 

Это удобно, если вы имеете ряд сохраненных патчей, потому что вы можете сначала просмотреть патч, если вы забыли, что он из себя представляет, или не применять уже примененный ранее патч.

This is nice if you have a number of patches saved, because you can view the patch first if you don’t remember what it is, or not apply the patch if you’ve already done so.

Когда все патчи для вашей темы работы применены и для них выполнен коммит в вашу ветку, вы можете принимать решение — интегрировать ли их в ваши 'более постоянные' ветки и если да, то каким образом.

When all the patches for your topic are applied and committed into your branch, you can choose whether and how to integrate them into a longer-running branch.

### Проверка удаленных веток ###

### Checking Out Remote Branches ###

Если участник вашего проекта является пользователем Git, который создал свой собственный репозиторий, отправил в него несколько изменений, а затем прислал вам URL этого репозитория и имя удаленной ветки, в которой находятся изменения, вы можете добавить его как удаленный репозиторий и выполнить слияние локально.

If your contribution came from a Git user who set up their own repository, pushed a number of changes into it, and then sent you the URL to the repository and the name of the remote branch the changes are in, you can add them as a remote and do merges locally.

Например, если Джессика присылает вам e-mail, в котором говорится, что у нее есть классная новая наработка в ветке `ruby-client` ее репозитория, вы можете протестировать ее, добавив ее репозиторий в качестве удаленного для вашего проекта и проверив эту ветку локально:

For instance, if Jessica sends you an e-mail saying that she has a great new feature in the `ruby-client` branch of her repository, you can test it by adding the remote and checking out that branch locally:

	$ git remote add jessica git://github.com/jessica/myproject.git
	$ git fetch jessica
	$ git checkout -b rubyclient jessica/ruby-client

Если она позже снова пишет вам e-mail, в котором говорит о другой ветке с классными наработками, вы можете извлечь эти наработки и переключится на эту ветку, так как вы уже добавили ее репозиторий в качестве удаленного для вашего проекта.

If she e-mails you again later with another branch containing another great feature, you can fetch and check out because you already have the remote setup.

Этот метод наиболее удобен, если вы работаете с человеком постоянно. Если кто-либо изредка представляет вам по одному патчу, то менее затратно по времени будет принимать его через e-mail, чем заставлять каждого иметь свой собственный репозиторий и постоянно добавлять и удалять удаленные (remotes) репозитории, чтобы получить несколько патчей. Также, вероятно, вы не захотите иметь сотни удаленных репозиториев в вашем проекте, каждый из которых предоставляет вам один или два патча. Однако, скрипты могут упростить эту ситуацию — все зависит от того, как ведете разработку вы и участники вашего проекта.

This is most useful if you’re working with a person consistently. If someone only has a single patch to contribute once in a while, then accepting it over e-mail may be less time consuming than requiring everyone to run their own server and having to continually add and remove remotes to get a few patches. You’re also unlikely to want to have hundreds of remotes, each for someone who contributes only a patch or two. However, scripts and hosted services may make this easier — it depends largely on how you develop and how your contributors develop.

Другим преимуществом данного подхода является тот факт, что сохраняется также и история коммитов. Although you may have legitimate merge issues, you know where in your history their work is based. Правильное трехходовое слияние предпочтительнее использования опции `-3`, когда нужно надеяться, что патч был сгенерирован на основе публичного коммита, к которому вы имеете доступ.

The other advantage of this approach is that you get the history of the commits as well. Although you may have legitimate merge issues, you know where in your history their work is based; a proper three-way merge is the default rather than having to supply a `-3` and hope the patch was generated off a public commit to which you have access.

Если вы не работаете с человеком постоянно, но все же хотите принимать его изменения таким образом, вы можете указать URL удаленного репозитория в команде `git pull`. В результате будут получены нужные изменения, а URL не будет сохранен в списке удаленных репозиториев вашего проекта:

If you aren’t working with a person consistently but still want to pull from them in this way, you can provide the URL of the remote repository to the `git pull` command. This does a one-time pull and doesn’t save the URL as a remote reference:

	$ git pull git://github.com/onetimeguy/project.git
	From git://github.com/onetimeguy/project
	 * branch            HEAD       -> FETCH_HEAD
	Merge made by recursive.

### Определение вносимых изменений ###

### Determining What Is Introduced ###

Сейчас у вас есть тематическая ветка, содержащая наработки участников проекта. На этом этапе вы можете определить, что бы вы хотели с ними сделать. В этом разделе проводится обзор пары команд, которые, как вы увидите, можно использовать для точного определения того, что будет получено при выполнении слияния тематической ветки с вашей основной веткой.

Now you have a topic branch that contains contributed work. At this point, you can determine what you’d like to do with it. This section revisits a couple of commands so you can see how you can use them to review exactly what you’ll be introducing if you merge this into your main branch.

Часто полезным является просмотр всех коммитов, которые находятся в этой ветке, но которых нет в вашей master ветке. Вы можете исключить коммиты из master ветки путем добавления опции `--not` перед именем ветки. Например, если участник вашего проекта присылает вам два патча и вы создаете ветку с именем `contrib` и применяете в ней эти патчи, вы можете выполнить следующую команду:

It’s often helpful to get a review of all the commits that are in this branch but that aren’t in your master branch. You can exclude commits in the master branch by adding the `--not` option before the branch name. For example, if your contributor sends you two patches and you create a branch called `contrib` and applied those patches there, you can run this:

	$ git log contrib --not master
	commit 5b6235bd297351589efc4d73316f0a68d484f118
	Author: Scott Chacon <schacon@gmail.com>
	Date:   Fri Oct 24 09:53:59 2008 -0700

	    seeing if this helps the gem

	commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
	Author: Scott Chacon <schacon@gmail.com>
	Date:   Mon Oct 22 19:38:36 2008 -0700

	    updated the gemspec to hopefully work better

Чтобы просмотреть какие изменения вносит каждый коммит, запомните, что вы можете указать опцию `-p` в команде `git log` — к каждому коммиту будет добавлен его diff.

To see what changes each commit introduces, remember that you can pass the `-p` option to `git log` and it will append the diff introduced to each commit.

Чтобы просмотреть полный diff при слиянии этой тематической ветки с другой веткой, вы можете использовать интересный трюк. Выполняйте следующую команду: 

To see a full diff of what would happen if you were to merge this topic branch with another branch, you may have to use a weird trick to get the correct results. You may think to run this:

	$ git diff master

Эта команда выведет вам diff, но результат может оказаться обманчивым. Если ваша ветка `master` была промотана вперед с того момента, когда вы создали на ее основе тематическую ветку, вы, наверняка, увидите странный результат. Это происходит по той причине, что Git напрямую сравнивает снимки последнего коммита тематической ветки, на которой вы находитесь, и снимок последнего коммита ветки `master`. Например, если вы добавили строку в файл в ветке `master`, прямое сравнение снимков покажет, что изменения в тематической ветке собираются удалить эту строку.

This command gives you a diff, but it may be misleading. If your `master` branch has moved forward since you created the topic branch from it, then you’ll get seemingly strange results. This happens because Git directly compares the snapshots of the last commit of the topic branch you’re on and the snapshot of the last commit on the `master` branch. For example, if you’ve added a line in a file on the `master` branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.

Если `master` является прямым предком вашей тематической ветки, то проблем нет. Но если две линии истории разошлись, то diff будет выглядеть как будто вы добавляете все новое из вашей тематической ветки и удаляете все уникальное из ветки `master`.

If `master` is a direct ancestor of your topic branch, this isn’t a problem; but if the two histories have diverged, the diff will look like you’re adding all the new stuff in your topic branch and removing everything unique to the `master` branch.

То, что вы реально хотели бы видеть — изменения из тематической ветки, то есть те наработки, которые вы внесете при слиянии этой ветки с master веткой. Это выполняется путем сравнения последнего коммита в вашей тематической ветке с первым общим предком, который она имеет с master веткой.

What you really want to see are the changes added to the topic branch — the work you’ll introduce if you merge this branch with master. You do that by having Git compare the last commit on your topic branch with the first common ancestor it has with the master branch.

Технически, вы можете сделать это, явно выделяя общего предка и затем выполняя команду diff:

Technically, you can do that by explicitly figuring out the common ancestor and then running your diff on it:

	$ git merge-base contrib master
	36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
	$ git diff 36c7db 

Однако это не очень удобно, так что Git предоставляет другой вариант для выполнения той же самой операции: троеточие. В контексте команды `diff`, вы можете поставить три точки после названия одной из веток, чтобы увидеть diff между последним коммитом ветки, на которой вы находитесь, и их общим предком с другой веткой:

However, that isn’t convenient, so Git provides another shorthand for doing the same thing: the triple-dot syntax. In the context of the `diff` command, you can put three periods after another branch to do a `diff` between the last commit of the branch you’re on and its common ancestor with another branch:

	$ git diff master...contrib

Эта команда показывает вам только те наработки в вашей текущей тематической ветке, которые были внесены после расхождения с их общим предком в master ветке. Это очень удобный синтаксис и его надо запомнить.

This command shows you only the work your current topic branch has introduced since its common ancestor with master. That is a very useful syntax to remember.

### Интегрирование наработок ###

### Integrating Contributed Work ###

Когда все наработки в вашей тематической ветке готовы к интегрированию в более главную ветку, встает вопрос — как это сделать? Более того — какой рабочий процесс в целом вы хотите использовать, занимаясь поддержкой своего проекта? Есть несколько вариантов, так что рассмотрим некоторые из них.

When all the work in your topic branch is ready to be integrated into a more mainline branch, the question is how to do it. Furthermore, what overall workflow do you want to use to maintain your project? You have a number of choices, so I’ll cover a few of them.

#### Рабочие процессы со слиянием ####

#### Merging Workflows ####

Один из простых рабочих процессов заключается в слиянии наработок с вашей веткой `master`. В этом случае ваша ветка `master` содержит основную стабильную версию кода. Когда вы проверили ваши собственные или полученные от кого-либо наработки, находящиеся в тематической ветке, вы объединяете ее с вашей master веткой, удаляете тематическую ветку, а затем продолжаете работу. Если в вашем репозитории наработки находятся в двух ветках, названия которых `ruby_client` и `php_client` (Рисунок 5-19), и вы выполняете слияние сначала для ветки `ruby_client`, в потом для `php_client`, то ваша история коммитов, в итоге, будет выглядеть как на Рисунке 5-20.    

One simple workflow merges your work into your `master` branch. In this scenario, you have a `master` branch that contains basically stable code. When you have work in a topic branch that you’ve done or that someone has contributed and you’ve verified, you merge it into your master branch, delete the topic branch, and then continue the process.  If we have a repository with work in two branches named `ruby_client` and `php_client` that looks like Figure 5-19 and merge `ruby_client` first and then `php_client` next, then your history will end up looking like Figure 5-20.

Insert 18333fig0519.png
Рисунок 5-19. История коммитов с несколькими тематическими ветками.
 
Figure 5-19. History with several topic branches.

Insert 18333fig0520.png
Рисунок 5-20. История коммитов после слияния тематических веток с master веткой.

Figure 5-20. After a topic branch merge.

Это, по всей видимости, наиболее простой рабочий процесс, но при работе с большими проектами здесь возникает ряд проблем.

That is probably the simplest workflow, but it’s problematic if you’re dealing with larger repositories or projects.

Если ваш проект более крупный, или вы работаете с большим количеством разработчиков, вы, вероятно, будете применять по крайней мере двухэтапный цикл слияний. В этом случае у вас есть две долго живущие ветки, `master` и `develop`, для которых вы решили, что ветка `master` обновляется только когда выходит очень стабильный релиз, и весь код включен в ветку `develop`. Вы регулярно отправляете изменения для обоих этих веток в публичный репозиторий. Каждый раз, когда у вас появляется новая тематическая ветка для слияния (Рисунок 5-21), вы, сначала, объединяете ее с веткой `develop` (Рисунок 5-22); затем, когда вы выпускаете  релиз, вы делаете перемотку (fast-forward) ветки `master` на требуемый стабильный снимок ветки `develop` (Рисунок 5-23).

If you have more developers or a larger project, you’ll probably want to use at least a two-phase merge cycle. In this scenario, you have two long-running branches, `master` and `develop`, in which you determine that `master` is updated only when a very stable release is cut and all new code is integrated into the `develop` branch. You regularly push both of these branches to the public repository. Each time you have a new topic branch to merge in (Figure 5-21), you merge it into `develop` (Figure 5-22); then, when you tag a release, you fast-forward `master` to wherever the now-stable `develop` branch is (Figure 5-23).

Insert 18333fig0521.png
Рисунок 5-21. История коммитов до слияния тематической ветки.
 
Figure 5-21. Before a topic branch merge.

Insert 18333fig0522.png
Рисунок 5-22. История коммитов после слияния тематической ветки.
 
Figure 5-22. After a topic branch merge.

Insert 18333fig0523.png
Рисунок 5-23. История коммитов после появления релиза.
 
Figure 5-23. After a topic branch release.

При таком подходе, клонируя ваш репозиторий люди могут либо переключиться на вашу master ветку, чтобы получить последний стабильный релиз и легко проводить обновление, либо переключиться на ветку `develop`, которая включает в себя все самое свежее.
Вы также можете развить данный подход, создав ветку для интегрирования, в которой будет происходить слияние всех наработок. И когда вы посчитаете, что код на этой ветке является стабильным и проходит все тесты, вы выполняете слияние этой ветки с веткой `develop`; и если все работает как положено некоторое время, вы выполняете перемотку вашей master ветки.

This way, when people clone your project’s repository, they can either check out master to build the latest stable version and keep up to date on that easily, or they can check out develop, which is the more cutting-edge stuff.
You can also continue this concept, having an integrate branch where all the work is merged together. Then, when the codebase on that branch is stable and passes tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.

#### Рабочие процессы с крупными слияниями ####

#### Large-Merging Workflows ####

Проект в Git имеет 4 долго живущие ветки: `master`, `next`, `pu` (proposed updates) для новых наработок и `maint` для ретроподдержки (backports). Когда участники проекта подготавливают свои наработки, они объединяются в тематические ветки в репозитории мейнтейнера проекта  — нечто похожее показано на рисунке 5-24. На этом этапе проводится оценка значимости проделанной работы  — все ли работает как положено, стабилен ли код, или требуется выполнить больше работы. Если все в норме, то тематические ветки сливаются в ветку `next`, которая отправляется на сервер (push), так что каждый будет иметь возможность опробовать все предложенные в тематических ветках изменения.

The Git project has four long-running branches: `master`, `next`, and `pu` (proposed updates) for new work, and `maint` for maintenance backports. When new work is introduced by contributors, it’s collected into topic branches in the maintainer’s repository in a manner similar to what I’ve described (see Figure 5-24). At this point, the topics are evaluated to determine whether they’re safe and ready for consumption or whether they need more work. If they’re safe, they’re merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.

Insert 18333fig0524.png
Рисунок 5-24. Управление рядом параллельных тематических веток участников проекта.
 
Figure 5-24. Managing a complex series of parallel contributed topic branches.

Если тематические ветки требуют доработки, они сливаются в ветку `pu`. When it’s determined that they’re totally stable, the topics are re-merged into `master` and are then rebuilt from the topics that were in `next` but didn’t yet graduate to `master`. Это означает, что `master` практически всегда движется в прямом направлении, ветка `next` перемещается (rebase) иногда, а ветка `pu` перемещается чаще всех (смотри Рисунок 5-25).

If the topics still need work, they’re merged into `pu` instead. When it’s determined that they’re totally stable, the topics are re-merged into `master` and are then rebuilt from the topics that were in `next` but didn’t yet graduate to `master`. This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often (see Figure 5-25).

Insert 18333fig0525.png
Рисунок 5-25. Слияние тематических веток участников проекта в долго живущие ветки для интегрирования.
 
Figure 5-25. Merging contributed topic branches into long-term integration branches.

Когда тематическая ветка была полностью объединена с веткой `master`, она удаляется из репозитория. Проект также имеет ветку `maint`, которая ответвлена от последнего релиза и предоставляет backport-патчи, в случае если требуется maintenanсe-релиз. Таким образом, когда вы клонируете Git репозиторий, вы располагаете четырьмя ветками, переключаясь на которые вы можете оценивать проект на разных стадиях разработки (в зависимости от того, насколько свежей/стабильной версией вы хотите располагать или от того, каким образом вы хотите дополнять проект своими наработками); а мейнтейнер, в свою очередь, имеет структурированный рабочий процесс, который помогает ему оценивать новых участников проекта.

When a topic branch has finally been merged into `master`, it’s removed from the repository. The Git project also has a `maint` branch that is forked off from the last release to provide backported patches in case a maintenance release is required. Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.

#### Рабочие процессы с перемещениями и отбором лучшего ####

#### Rebasing and Cherry Picking Workflows ####

Другие мейнтейнеры вместо слияния предпочитают выполнять перемещение или отбор лучших наработок участников проекта на верхушку своей master ветки, чтобы иметь практически линейную историю разработки. Когда у вас есть наработки в тематической ветке, которые вы хотите интегрировать в проект, вы переходите на эту ветку и запускаете команду rebase, которая перемещает изменения на верхушку вашей текущей master ветки (или ветки `develop`, и т.п). Если все прошло хорошо, вы можете выполнить перемотку ветки `master`, получив тем самым линейную историю работы над проектом.

Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history. When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or `develop`, and so on) branch. If that works well, you can fast-forward your `master` branch, and you’ll end up with a linear project history.

Другой вариант перемещения сделанных наработок из одной ветки в другую - отбор лучшего. Отбор лучшего в Git является чем-то наподобие перемещения для отдельных коммитов. Берется патч, который был представлен в коммите, и делается попытка применить его на ветке, на которой вы сейчас находитесь. Это удобно в том случае, если у вас есть ряд коммитов в тематической ветке и вы хотите включить в проект только один из них, или если у вас только один коммит в тематической ветке и вы предпочитаете выполнять отбор лучшего вместо перемещения. Например, предположим ваш проект выглядит так, как показано на Рисунке 5-26.

The other way to move introduced work from one branch to another is to cherry-pick it. A cherry-pick in Git is like a rebase for a single commit. It takes the patch that was introduced in a commit and tries to reapply it on the branch you’re currently on. This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you’d prefer to cherry-pick it rather than run rebase. For example, suppose you have a project that looks like Figure 5-26.

Insert 18333fig0526.png 
Рисунок 5-26. Пример истории коммитов перед отбором лучшего.

Figure 5-26. Example history before a cherry pick.

Если вы хотите отправить коммит `e43a6` в вашу master ветку, вы выполняете:

If you want to pull commit `e43a6` into your master branch, you can run

	$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
	Finished one cherry-pick.
	[master]: created a0a41a9: "More friendly message when locking the index fails."
	 3 files changed, 17 insertions(+), 3 deletions(-)

Эта команда включает в master ветку изменения, представленные в `e43a6`, но вы получаете новое значение SHA-1 для этого коммита, так как у него будет другая дата принятия. Теперь ваша история коммитов выглядит как показано на Рисунке 5-27.

This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different. Now your history looks like Figure 5-27.

Insert 18333fig0527.png 
Рисунок 5-27. История коммитов после отбора лучшего коммита из тематической ветки.

Figure 5-27. History after cherry-picking a commit on a topic branch.

Теперь вы можете удалить вашу тематическую ветку и отбросить коммиты, которые вы не хотели бы включать в проект.

Now you can remove your topic branch and drop the commits you didn’t want to pull in.

### Установка меток для релизов ###

### Tagging Your Releases ###

Когда вы решили выпустить релиз, вы, вероятно, захотите присвоить ему метку, так чтобы вы могли обновить этот релиз в любой момент в будущем. Процесс создания новой метки обсуждался в Главе 2. Если вы решите подписать (sign) вашу метку как мейнтейнер, процедура будет выглядеть примерно следующим образом:

When you’ve decided to cut a release, you’ll probably want to drop a tag so you can re-create that release at any point going forward. You can create a new tag as I discussed in Chapter 2. If you decide to sign the tag as the maintainer, the tagging may look something like this:

	$ git tag -s v1.5 -m 'my signed 1.5 tag'
	You need a passphrase to unlock the secret key for
	user: "Scott Chacon <schacon@gmail.com>"
	1024-bit DSA key, ID F721C45A, created 2009-02-09

Если вы подписали свои метки, у вас может возникнуть проблема с распространением открытого PGP ключа, использовавшегося для подписи ваших меток. Мейнтейнер проекта в Git может решить эту проблему включением публичного ключа в виде блоба (blob) в репозиторий и затем добавлением метки, которая напрямую указывает на этот контент. Чтобы сделать это, вы определяете какой ключ вам нужен запуском команды  `gpg --list-keys`:

If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags. The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content. To do this, you can figure out which key you want by running `gpg --list-keys`:

	$ gpg --list-keys
	/Users/schacon/.gnupg/pubring.gpg
	---------------------------------
	pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
	uid                  Scott Chacon <schacon@gmail.com>
	sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]

Затем вы можете напрямую импортировать ключ в базу данных Git путем экспортирования его и передачи (piping) команде `git hash-object`, которая создает новый блоб с этим контентом и возвращает вам SHA-1 от этого блоба:

Then, you can directly import the key into the Git database by exporting it and piping that through `git hash-object`, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:

	$ gpg -a --export F721C45A | git hash-object -w --stdin
	659ef797d181633c87ec71ac3f9ba29fe5775b92

Теперь, когда у вас в Git хранится ваш ключ, вы можете создать метку, напрямую указывающую на него, путем использования значения SHA-1, возвращенного вам командой `hash-object`:

Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the `hash-object` command gave you:

	$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92

Если вы запустите команду `git push --tags`, то метка `maintainer-pgp-pub` будет доступена каждому. Если кто-либо захочет проверить метку, он может напрямую импортировать ваш PGP ключ, скачивая (pulling) блоб из базы данных и импортируя его в GPG:

If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared with everyone. If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:

	$ git show maintainer-pgp-pub | gpg --import

Этот ключ может быть использован для проверки всех ваших подписанных меток. Также, если вы включите инструкции в сообщение метки, запуск `git show <метка>` позволит конечному пользователю получить инструкции по проверке метки.

They can use that key to verify all your signed tags. Also, if you include instructions in the tag message, running `git show <tag>` will let you give the end user more specific instructions about tag verification.

### Создание номера сборки ###

### Generating a Build Number ###

Так как коммитам в Git не присваиваются постоянно нарастающие номера, наподобие 'v123' или чего-то аналогичного, то в случае, если вы захотите присвоить коммиту human-readable имя, можно запустить команду `git describe` для этого коммита. Git возвращает вам имя ближайшей метки вместе с числом коммитов поверх этой метки и часть значения SHA-1 описываемого вами коммита: 

Because Git doesn’t have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit. Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you’re describing:

	$ git describe master
	v1.6.2-rc1-20-g8c5b85c

Таким образом вы можете экспортировать снимок проекта или сборку и присвоить им понятное для человека имя. На самом деле, если вы собираете Git из исходного кода, клонированного из Git-репозитория, `git --version` возвращает вам что-то подобное. Если вы описываете коммит, которому вы напрямую присвоили метку, команда вернет вам имя метки.

This way, you can export a snapshot or build and name it something understandable to people. In fact, if you build Git from source code cloned from the Git repository, `git --version` gives you something that looks like this. If you’re describing a commit that you have directly tagged, it gives you the tag name.

Команду `git describe` хорошо использовать с аннотированными метками (метками, созданными при помощи опций `-a` или `-s`), так что если вы используете `git describe`, то метки для релизов должны создаваться этим способом - в этом случае вы сможете удостовериться, что при описании коммиту было дано правильное имя. Вы также можете использовать эту строку в командах `checkout` и `checkout` для указания нужного коммита, однако это не может вечно работать правильно в силу того, что в строке присутствует сокращенное значение SHA-1. Например, в ядре Linux недавно перешли от 8 к 10 символам, чтобы удостовериться в уникальности SHA-1 объекта, и поэтому старый вывод команды `git describe` признается недействительным.

The `git describe` command favors annotated tags (tags created with the `-a` or `-s` flag), so release tags should be created this way if you’re using `git describe`, to ensure the commit is named properly when described. You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever. For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older `git describe` output names were invalidated.

### Подготовка релиза ###

### Preparing a Release ###

Теперь вы хотите выпустить релиз сборки. Вероятно вы захотите сделать архив последнего снимка вашего кода для тех бедолаг, которые не используют Git. Для этого используется команда `git archive`:

Now you want to release a build. One of the things you’ll want to do is create an archive of the latest snapshot of your code for those poor souls who don’t use Git. The command to do this is `git archive`:

	$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
	$ ls *.tar.gz
	v1.6.2-rc1-20-g8c5b85c.tar.gz

Если кто-либо открывает этот tarball, он получит последний снимок вашего проекта внутри директории `project`. Таким же способом вы можете создать zip архив, указав команде `git archive` опцию `--format=zip`:

If someone opens that tarball, they get the latest snapshot of your project under a project directory. You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`:

	$ git archive master --prefix='project/' --format=zip > `git describe master`.zip

Теперь у вас есть tarball и zip архив с релизом вашего проекта, которые вы можете загрузить на сайт или отправить людям по почте. 

You now have a nice tarball and a zip archive of your project release that you can upload to your website or e-mail to people.

### Команда `shortlog` ###

### The Shortlog ###

Настало время написать по почте людям из вашего списка рассылки, которые хотят получать новости о вашем проекте. При помощи команды `git shortlog` можно быстро получить что-то наподобие лога изменений (changelog), содержащего изменения в вашем проекте, сделанные после последнего релиза или последнего письма по списку рассылки. Лог изменений включает в себя все коммиты в указанном диапазоне; например, следующая команда вернет вам сводку по всем коммитам после последнего релиза (последний релиз имел метку v1.0.1):

It’s time to e-mail your mailing list of people who want to know what’s happening in your project. A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or e-mail is to use the `git shortlog` command. It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:

	$ git shortlog --no-merges master --not v1.0.1
	Chris Wanstrath (8):
	      Add support for annotated tags to Grit::Tag
	      Add packed-refs annotated tag support.
	      Add Grit::Commit#to_patch
	      Update version and History.txt
	      Remove stray `puts`
	      Make ls_tree ignore nils

	Tom Preston-Werner (4):
	      fix dates in history
	      dynamic version method
	      Version bump to 1.0.2
	      Regenerated gemspec for version 1.0.2

Вы получаете аккуратную сводку по всем коммитам, начиная с метки v1.0.1, сгруппированных по автору. Вывод этой команды можно посылать по вашему списку рассылки.

You get a clean summary of all the commits since v1.0.1, grouped by author, that you can e-mail to your list.

## Итоги ##

Вы должны чувствовать себя достаточно свободно, внося свой вклад в проект под управлением Git, а также занимаясь поддержкой вашего собственного проекта или интегрированием наработок других пользователей. Поздравляем тебя, опытный Git-разработчик! В следующей главе вы познакомитесь с более мощными инструментами, а также получите советы по действию в сложных ситуациях, которые сделают из вас настоящего мастера в Git.

You should feel fairly comfortable contributing to a project in Git as well as maintaining your own project or integrating other users’ contributions. Congratulations on being an effective Git developer! In the next chapter, you’ll learn more powerful tools and tips for dealing with complex situations, which will truly make you a Git master.
